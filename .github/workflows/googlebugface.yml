name: Googleidx Keep Live

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true 

on:
  schedule:
    - cron: '0 * * * *' 
  workflow_dispatch:

jobs:
  dynamic-keep-alive:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Chinese Fonts
        run: |
          sudo apt-get update
          sudo apt-get install -y fonts-noto-cjk

      - name: Install Tools
        run: |
          npm init -y
          npm install playwright
          npx playwright install chromium --with-deps

      - name: Run Infinite Random Loop
        env:
          # ä¸¥æ ¼ä» Secrets è¯»å–ç›®æ ‡ç½‘å€
          TARGET_URL: ${{ secrets.TARGET_URL }} 
          TG_TOKEN: ${{ secrets.TG_TOKEN }} 
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
        run: |
          node -e "
          const { chromium } = require('playwright');
          const exec = require('child_process').execSync;

          function sendToTG(caption, photoPath = null) {
            const token = process.env.TG_TOKEN;
            const chatId = process.env.TG_CHAT_ID;
            if (!token || !chatId) return;
            try {
              let cmd;
              if (photoPath) {
                cmd = \`curl -s -F \"chat_id=\${chatId}\" -F \"photo=@\${photoPath}\" -F \"caption=\${caption}\" https://api.telegram.org/bot\${token}/sendPhoto\`;
              } else {
                cmd = \`curl -s -d \"chat_id=\${chatId}\" -d \"text=\${caption}\" https://api.telegram.org/bot\${token}/sendMessage\`;
              }
              exec(cmd);
            } catch (e) { console.log('TGå‘é€å¤±è´¥'); }
          }

          (async () => {
            // ä»ç¯å¢ƒå˜é‡è·å–ç½‘å€
            const targetUrl = process.env.TARGET_URL;
            if (!targetUrl) {
                console.error('é”™è¯¯ï¼šæœªæ£€æµ‹åˆ° TARGET_URL å˜é‡ï¼Œè¯·æ£€æŸ¥ Secrets é…ç½®ï¼');
                process.exit(1);
            }
            
            const initialDelay = Math.floor(Math.random() * 5 * 60 * 1000);
            console.log('å¯åŠ¨å»¶è¿Ÿ: ' + (initialDelay/60000).toFixed(1) + ' åˆ†é’Ÿ');
            await new Promise(r => setTimeout(r, initialDelay));

            const browser = await chromium.launch({ args: ['--disable-dev-shm-usage'] });
            const context = await browser.newContext({
              viewport: { width: 1280, height: 1200 },
              locale: 'zh-CN',
              userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36'
            });
            const page = await context.newPage();

            try {
              console.log('æ­£åœ¨è®¿é—®å˜é‡åœ°å€: ' + targetUrl);
              await page.goto(targetUrl, { waitUntil: 'domcontentloaded', timeout: 60000 });
              await new Promise(r => setTimeout(r, 15000)); 
              await page.screenshot({ path: 'monitor.png', fullPage: true });
              
              const bjTime = new Date(new Date().getTime() + 8 * 60 * 60 * 1000).toISOString().replace(/T/, ' ').replace(/\\..+/, '');
              sendToTG('âœ… ç›‘æ§æ¥åŠ›æˆåŠŸ\\nâ° æ—¶é—´: \${bjTime}\\nğŸ”— ç›®æ ‡: \${targetUrl}', 'monitor.png');

              console.log('è¿›å…¥æ— é™åˆ·æ–°æ¨¡å¼...');
              while (true) {
                const interval = Math.floor(Math.random() * (120 - 60 + 1) + 60) * 1000;
                await new Promise(r => setTimeout(r, interval));
                await page.reload({ waitUntil: 'domcontentloaded' });
                await page.mouse.wheel(0, Math.floor(Math.random() * 400));
              }
            } catch (err) {
              console.error('è¿è¡Œå‡ºé”™:', err.message);
              sendToTG('âš ï¸ ç›‘æ§å¼‚å¸¸: ' + err.message);
            } finally {
              await browser.close();
            }
          })();
          "

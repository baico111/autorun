name: Google Idx Monitor

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true 

on:
  on:
  schedule:
    - cron: '0 */5 * * *' # æ„æ€æ˜¯æ¯éš” 5 å°æ—¶çš„ 0 åˆ†è¿è¡Œä¸€æ¬¡
  workflow_dispatch:

jobs:
  dynamic-keep-alive:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Chinese Fonts
        run: |
          sudo apt-get update
          sudo apt-get install -y fonts-noto-cjk

      - name: Install Tools
        run: |
          npm init -y
          npm install playwright
          npx playwright install chromium --with-deps

      - name: Run Infinite Random Loop
        env:
          TARGET_URL: ${{ secrets.TARGET_URL }} 
          TG_TOKEN: ${{ secrets.TG_TOKEN }} 
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
        run: |
          node -e "
          const { chromium } = require('playwright');
          const exec = require('child_process').execSync;

          function sendToTG(caption, photoPath = null) {
            const token = process.env.TG_TOKEN;
            const chatId = process.env.TG_CHAT_ID;
            if (!token || !chatId) return;
            try {
              let cmd;
              if (photoPath) {
                const escapedCaption = caption.replace(/\"/g, '\\\"');
                cmd = \`curl -s -F \"chat_id=\${chatId}\" -F \"photo=@\${photoPath}\" -F \"caption=\${escapedCaption}\" https://api.telegram.org/bot\${token}/sendPhoto\`;
              } else {
                cmd = \`curl -s -d \"chat_id=\${chatId}\" -d \"text=\${caption}\" https://api.telegram.org/bot\${token}/sendMessage\`;
              }
              exec(cmd);
            } catch (e) { console.log('TGå‘é€å¤±è´¥'); }
          }

          (async () => {
            const targetUrl = process.env.TARGET_URL;
            if (!targetUrl) process.exit(1);

            // 1. éšæœºå¯åŠ¨å»¶è¿Ÿ (å›ºå®šåœ¨ 2 åˆ° 5 åˆ†é’Ÿ)
            // 2åˆ†=120000ms, 5åˆ†=300000ms
            const initialDelay = Math.floor(Math.random() * (300000 - 120000 + 1) + 120000);
            console.log('éšæœºå¯åŠ¨å»¶è¿Ÿ: ' + (initialDelay/60000).toFixed(2) + ' åˆ†é’Ÿ');
            await new Promise(r => setTimeout(r, initialDelay));

            const browser = await chromium.launch({ args: ['--disable-dev-shm-usage'] });
            const context = await browser.newContext({
              viewport: { width: 1280, height: 1200 },
              locale: 'zh-CN',
              userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36'
            });
            const page = await context.newPage();

            try {
              console.log('æ­£åœ¨è®¿é—®ç›®æ ‡é¡µé¢...');
              await page.goto(targetUrl, { waitUntil: 'domcontentloaded', timeout: 60000 });
              await new Promise(r => setTimeout(r, 15000)); 
              await page.screenshot({ path: 'monitor.png', fullPage: true });

              // 2. æ ¼å¼åŒ–åŒ—äº¬æ—¶é—´ (YYYY-MM-DD HH:mm:ss)
              const d = new Date(new Date().getTime() + 8 * 60 * 60 * 1000);
              const year = d.getUTCFullYear();
              const month = String(d.getUTCMonth() + 1).padStart(2, '0');
              const day = String(d.getUTCDate()).padStart(2, '0');
              const hours = String(d.getUTCHours()).padStart(2, '0');
              const minutes = String(d.getUTCMinutes()).padStart(2, '0');
              const seconds = String(d.getUTCSeconds()).padStart(2, '0');
              const bjTime = \`\${year}-\${month}-\${day} \${hours}:\${minutes}:\${seconds}\`;

              // 3. æ„é€ æ¶ˆæ¯å†…å®¹ï¼šç›®æ ‡æ˜¾ç¤ºä¸º Google Idx
              const msg = \`âœ… ç›‘æ§æ¥åŠ›æˆåŠŸ\\nâ° æ—¶é—´: \${bjTime} (åŒ—äº¬æ—¶é—´)\\nğŸ”— ç›®æ ‡: Google Idx\`;
              
              sendToTG(msg, 'monitor.png');

              // 4. æ— é™åˆ·æ–°å¾ªç¯ (1-2åˆ†é’Ÿéšæœºåˆ·æ–°)
              while (true) {
                const interval = Math.floor(Math.random() * (120 - 60 + 1) + 60) * 1000;
                await new Promise(r => setTimeout(r, interval));
                await page.reload({ waitUntil: 'domcontentloaded' });
                await page.mouse.wheel(0, Math.floor(Math.random() * 500));
              }
            } catch (err) {
              sendToTG('âš ï¸ ç›‘æ§å¼‚å¸¸: ' + err.message);
            } finally {
              await browser.close();
            }
          })();
          "
